/**
 * This utility function, `createFixture`, generates a factory function for creating test data fixtures. It is designed to support
 * both static and dynamic test data generation with an emphasis on customization through custom options and per-call overrides.
 * The utility offers three modes of operation to accommodate various use cases: without custom options, with static custom
 * options, and with dynamic custom options provided via a getter function.
 *
 * Modes of Operation:
 * 1. **Without Custom Options**: For simple data generation that does not require custom options.
 * 2. **With Static Custom Options**: Allows specifying a static object of custom options to influence the data generation logic.
 * 3. **With Dynamic Custom Options**: Utilizes a getter function to provide dynamic default options, offering more flexibility.
 *
 * The returned factory function takes a `getValues` function, responsible for generating the base structure of the fixture.
 * This function can optionally use the provided custom options. An `overrides` object can also be passed to the factory function
 * for per-call customizations, allowing modification of both the initial custom options and the properties of the generated data.
 *
 * @typeparam T - The base type of the data generated by the fixture.
 * @typeparam P - The type of the custom options object, optional.
 * @param defaultOptionsOrGetter - An optional object of custom options or a function returning such an object.
 * These options are used within the `getValues` function to dynamically generate data.
 *
 * @returns A factory function that accepts a `getValues` function for generating the fixture's base data.
 * The factory function can be further invoked with an `overrides` object to customize the generated data per call.
 *
 * @example
 * Without custom options:
 * ```typescript
 * export const user = createFixture<User>()(() => ({
 *   id: faker.datatype.uuid(),
 *   name: faker.name.findName(),
 * }));
 * ```
 *
 * With custom options influencing data generation (not directly included in the output):
 * ```typescript
 * export const complexUserData = createFixture<User, { isActive: boolean }>({
 *   isActive: true,
 * })(({ isActive }) => ({
 *   id: faker.datatype.uuid(),
 *   name: faker.name.findName(),
 *   status: isActive ? 'active' : 'inactive',
 *   lastLogin: isActive ? new Date() : undefined,
 * }));
 * ```
 *
 * With dynamic custom options for flexible and context-specific data generation:
 * ```typescript
 * export const token = createFixture<Token, { sdkToken: SDKToken }>(() => ({
 *   sdkToken: randomChoice(TOKENS),
 * }))(({ sdkToken }) => ({
 *   ...contract(),
 *   id: faker.datatype.uuid(),
 *   name: sdkToken.name,
 *   symbol: sdkToken.symbol,
 *   decimals: sdkToken.decimals,
 *   chain: toGraphQLChain(sdkToken.chainId) ?? Chain.Ethereum,
 *   address: sdkToken.address,
 * }))
 * ```
 */
export declare function createFixture<T extends object>(): {
    <V extends T>(getValues: () => V): {
        <O extends Partial<T>>(overrides: O): V extends (infer I)[] ? (Omit<I, keyof O> & O)[] : Omit<V, keyof O> & O;
        (): V;
    };
};
export declare function createFixture<T extends object, P extends object>(defaultOptions: Required<P>): {
    <V extends T>(getValues: (options: P) => V): {
        <O extends Partial<T & P>>(overrides: O): V extends (infer I)[] ? (Omit<I, Exclude<keyof O, keyof T>> & Omit<O, keyof P>)[] : Omit<V, Exclude<keyof O, keyof T>> & Omit<O, keyof P>;
        (): V;
    };
};
export declare function createFixture<T extends object, P extends object>(getDefaultOptions: () => Required<P>): {
    <V extends T>(getValues: (options: P) => V): {
        <O extends Partial<T & P>>(overrides: O): V extends (infer I)[] ? (Omit<I, Exclude<keyof O, keyof T>> & Omit<O, keyof P>)[] : Omit<V, Exclude<keyof O, keyof T>> & Omit<O, keyof P>;
        (): V;
    };
};
//# sourceMappingURL=factory.d.ts.map